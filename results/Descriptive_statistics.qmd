---
title: "Descriptive statistics"
author:
  - name: "Sam Nooij"
    affiliations:
      - ref: UU-KLIF
    orcid: 0000-0001-5892-5637
    email: s.nooij [at] uu.nl
    corresponding: true

affiliations:
  - id: UU-KLIF
    name: Utrecht University
    department: Faculty of Veterinary Medicine, Department of Clinical Infectiology
    address: Yalelaan 1
    city: Utrecht
    country: The Netherlands
    postal-code: 3584CL

date: "2024-12-03"

execute: 
  echo: true
  warning: false
  message: false
  cache: true

format: 
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    df-print: paged
    fig-height: 4
    fig-width: 7
  pdf:
    documentclass: report
    classoption: [twocolumn, landscape]
    mainfont: "Open Sans"
    mainfontoptions:
      - Color=101010
    colorlinks: true
    toc: true
    toc-depth: 3
    number-sections: true
    number-depth: 3
    highlight-style: github

knitr:
  opts_chunk: 
    cache: true

editor:
  markdown:
    wrap: 72
  canonical: true
---

# CRISPR spacers in *Campylobacter*

**Descriptive statistics of CRISPR arrays in *Campylobacter* genomes
from
[AllTheBacteria](https://allthebacteria.readthedocs.io/ "AllTheBacteria documentation")**

We have downloaded all the *Campylobacter* *jejuni* and *C. coli*
genomes from AllTheBacteria (ATB) to screen for CRISPR spacers. The
current experiment includes all genomes that have been classified as
'Campylobacter_D jejuni\*' or 'Campylobacter_D coli\*' using
[Sylph](https://www.nature.com/articles/s41587-024-02412-y "Shaw & Yu, 2024. Nature Biotechnology")
(which the creators of ATB ran on all genomes), that have been added to
ATB in the incremental update of August 2024 (@fig-number_of_species).
(∗: any species designation matching these name prefixes were included.)
These genomes have been screened for CRISPR ([Clustered Regularly
Interspaced Short Palindromic
Repeats](https://en.wikipedia.org/wiki/CRISPR "CRISPR wiki")) spacers
and *cas* (CRISPR-associated) genes using
[CCTyper](https://www.biorxiv.org/content/10.1101/2020.05.15.097824v1 "Russel et al., 2020. bioRxiv")
(version 1.8.0). CCTyper produces tab-separated tables that summarise
the CRISPRs, including number of contigs containing CRISPR arrays,
number of spacers per array, number of repeat sequences, consensus
repeat sequence, and presence of *cas* genes. From these results, we can
view:

1.  The [number of CRISPR arrays](#crispr-arrays-per-genome) detected
    per genome (@fig-crisprs_per_genome)\
    (Taking into account the presence of *cas* genes)

2.  [Prevalence of CRISPR arrays](#arrays-per-genome-and-per-species)
    overall and per species (@fig-crisprs_per_genome_donut)

3.  [Type of CRISPR arrays] (and prevalence)

4.  Number of CRISPR [spacers per genome](#crispr-spacers-per-genome)
    (see @fig-spacers_per_genome) and [per
    species](#spacers-per-species) (see @fig-total_spacers_per_species)

5.  [Length of the CRISPR](#length-of-spacers-and-repeats) spacers and
    repeat sequences (@fig-repeat_and_spacer_length)

6.  [Number of unique spacer sequences](#number-of-unique-spacers)
    (figure: @fig-all_spacers_clustered)

7.  [Repeat consensus sequence diversity](#repeat-sequence-summary)

8.  Extra: estimated genome [assembly
    quality](#estimated-assembly-quality) (CheckM completeness and
    contamination; @fig-assembly_quality)

*Note: see the relevant [CCTyper
documentation](https://github.com/Russel88/CRISPRCasTyper?tab=readme-ov-file#output- "CCTyper output files documentation")
of output files.*

```{r setup, include=FALSE}
library(knitr)
library(rmarkdown)
library(here)
library(tidyverse)
library(ggpubr)
library(RColorBrewer)
library(viridisLite)
library(patchwork) # Combine figures while aligning axes
library(rstatix) # for convenient statistical tests and p-value reporting
library(scales) # for manually adjusting log-scale figure axes
library(colorspace) # for filling boxplots/violins with lighter shade of same colour

knitr::opts_knit$set(base.dir = here(""))
```

In this analysis report, we summarise the prevalence and other general
descriptive statistics of the CRISPR spacers. Therefore, we first need
to import the results from CCTyper:

```{r import_cctyper_results}
#| message: false

# Files were originally processed in batches
batches <- Sys.glob(here("data/tmp/cctyper/batch_*"))

# Read the tab-separated files for each batch and concatenate them
read_multiple_tables <- function(input_files) {
  return(
    data.frame(Filename = input_files,
               read_delim(input_files,
                          show_col_types = F,
                          trim_ws = T))
  )
}

# Try reading concatenated files, or read separate files from batches
#  and save as one concatenated file
read_or_create <- function(table_file) {
  if(file.exists(table_file)) {
    message(paste(basename(table_file), "exists already, reading from file!"))
    return(read_delim(table_file, show_col_types = F))

  } else {
    message(paste(
      basename(table_file),
      "does not yet exist. Concatenating batch tables..."))

    table_wildcard <- gsub(x = basename(table_file),
                           pattern = "concatenated",
                           replace = "*")
    file_list <- Sys.glob(paste0(batches, "/", table_wildcard))
    df <- do.call("rbind", lapply(file_list, read_multiple_tables))
    write_delim(x = df, file = table_file, delim = "\t")
    return(df)
  }
}

CRISPR_Cas_df <- read_or_create(
  here("data/processed/CRISPR_Cas-concatenated.tab")
)

crisprs_all_df <- read_or_create(
  here("data/processed/crisprs_all-concatenated.tab")
)

crisprs_near_cas_df <- read_or_create(
  here("data/processed/crisprs_near_cas-concatenated.tab")
  ) %>%
  select(-Contig) %>%
  separate_wider_delim(cols = CRISPR, delim = ".",
                       names = c("sample_accession", "Contig")) %>%
  separate_wider_delim(cols = Contig, delim = "_",
                       names = c("Contig", "CRISPR_number"))

crisprs_orphan_df <- read_or_create(
  here("data/processed/crisprs_orphan-concatenated.tab")
  ) %>%
  select(-Contig) %>%
  separate_wider_delim(cols = CRISPR, delim = ".",
                       names = c("sample_accession", "Contig")) %>%
  separate_wider_delim(cols = Contig, delim = "_",
                       names = c("Contig", "CRISPR_number"))
```

The output of CCTyper only contains sample accession IDs that can be
used to identify samples. Import a minimal set of ENA metadata and
species identifications by Sylph:

```{r import_metadata}
#| fig-width: 5
#| fig-height: 1
#| label: fig-number_of_species
#| fig-cap: "Number of species present in dataset"
#| message: false

campylobacter_metadata_file <- here("data/processed/Campylobacter_ATB_metadata.tsv")

if(file.exists(campylobacter_metadata_file)) {
  message("Reading Campylobacter metadata file!")
  campylobacter_metadata <- read_delim(
    campylobacter_metadata_file,
    show_col_types = F)

} else {
  message("Creating Campylobacter metadata file...")
  total_campylobacter_metadata <- read_delim(
    here("data/ATB/ena_metadata.20240801.selection-only_Campylobacter.tsv.gz"),
    delim = "\t",
    col_names = F,
    show_col_types = F)

  older_campylobacter_metadata <- read_delim(
    here("data/ATB/ena_metadata.0.2.20240606.selection-only_Campylobacter.tsv.gz"),
    delim = "\t",
    col_names = F,
    show_col_types = F)

  # Remove the older entries to keep only the Campylobacter genomes
  # from the incremental update
  campylobacter_metadata <- total_campylobacter_metadata %>%
    filter(! X2 %in% older_campylobacter_metadata$X1)

  # Take the column names from the table before grepping
  colnames(campylobacter_metadata) <- read_delim(
    file = here("data/ATB/ena_metadata.20240801.selection.tsv.gz"),
    n_max = 1,
    delim = "\t",
    show_col_types = F
  ) %>% colnames()

  # Remove columns that contain only NA values
  campylobacter_metadata <- campylobacter_metadata %>%
    select_if(~sum(!is.na(.)) > 0)

  simplified_species <- read_delim(
    file = here("data/ATB/sylph.tsv.gz"),
    delim = "\t",
    show_col_types = F) %>%
    select(Sample, Species)

  campylobacter_metadata <- left_join(
    x = campylobacter_metadata,
    y = simplified_species,
    by = c("sample_accession" = "Sample")
  )

  # Remove all genomes whose taxonomic annotation (species) does
  # not start with 'Campylobacter'
  campylobacter_metadata <- campylobacter_metadata %>%
    filter(grepl("Campylobacter_D jejuni|Campylobacter_D coli", Species))

  write_delim(x = campylobacter_metadata,
              file = campylobacter_metadata_file,
              delim = "\t")
}

campylobacter_species_numbers <- campylobacter_metadata %>%
  mutate(species = if_else(grepl("jejuni", Species), "jejuni", "coli")) %>%
  count(species)

# Alternative visualisation method: stacked bar chart
stacked_species_plot <- ggplot(data = campylobacter_species_numbers,
                             aes(x = 0, y = n, fill = species)) +
  geom_bar(stat = "identity") +
  theme_pubr() +
  ggtitle(paste("Total genomes:",
                format(sum(campylobacter_species_numbers$n),
                       big.mark = ","))) +
  theme(axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "right") +
  scale_fill_manual(name = "Species",
                    values = c("#895d45", "#c6903c")) +
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01))) +
  geom_text(aes(label = n %>%
                  format(big.mark = ",")),
            position = position_stack(vjust = 0.5),
            size = 4.5,
            color = "black")

stacked_species_plot
```

# CRISPR arrays per genome {#crispr-arrays-per-genome}

We have identified CRISPRs in all *Campylobacter jejuni* and *C. coli*
genomes using
[CCTyper](https://github.com/Russel88/CRISPRCasTyper "GitHub repository for CRISPRCasTyper").
CCTyper separately annotates CRISPRs near *cas* genes and separate
CRISPR arrays, called 'orphans'. To inventory the prevalence and size of
both types of CRISPR arrays, show for each genome the number of CRISPR
arrays as a scatterplot (@fig-crisprs_per_genome). (Derived from the
`CRISPR` field in CCTyper's output.)

```{r crisprs_per_genome}
#| label: fig-crisprs_per_genome
#| fig-cap: "Number of CRISPR arrays per genome"
#| fig-height: 4.5
#| fig-width: 7.5

annotated_crispr_number_df <- left_join(
  x = campylobacter_metadata %>%
    select(sample_accession, country, host, isolation_source,
           scientific_name, tax_id, Species, description),
  y = full_join(
    x = crisprs_near_cas_df %>%
      group_by(sample_accession) %>%
      count() %>%
      rename("CRISPRs near cas" = "n"),
    y = crisprs_orphan_df %>%
      group_by(sample_accession) %>%
      count() %>%
      rename("Orphan CRISPRs" = "n"),
    by = "sample_accession"
  )
) %>%
  mutate(
    across(`CRISPRs near cas`:`Orphan CRISPRs`,
           ~replace_na(., 0)),
    simple_species = if_else(grepl(pattern = "jejuni", x = Species),
                             "jejuni", "coli"),
    contains_crisprs = case_when(
      `CRISPRs near cas` == 0 & `Orphan CRISPRs` == 0 ~ "no_crisprs",
      `CRISPRs near cas` == 0 & `Orphan CRISPRs` > 0 ~ "only_orphans",
      `CRISPRs near cas` > 0 & `Orphan CRISPRs` == 0 ~ "only_near_cas",
      TRUE ~ "both"
    )
  )

write_delim(
  x = annotated_crispr_number_df,
  file = here("data/processed/CRISPR_numbers_annotated.tsv"),
  delim = "\t"
)

number_of_crisprs_scatterplot <- ggplot(
  data = annotated_crispr_number_df,
  mapping = aes(x = `CRISPRs near cas`,
                y = `Orphan CRISPRs`)
) +
  geom_point(position = position_jitter(),
             size = 0.7, alpha = 0.3) +
  theme_pubr()

crispr_near_cas_density = ggplot(
  data = annotated_crispr_number_df,
  mapping = aes(x = `CRISPRs near cas`)) +
  geom_density(fill = "grey20") +
  theme_pubr() +
  theme(axis.title.x = element_blank())

orphan_crispr_density = ggplot(
  data = annotated_crispr_number_df,
  mapping = aes(y = `Orphan CRISPRs`)) +
  geom_density(fill = "grey20") +
  theme_pubr()

design <- "
1111#
22223
22223
"

crisprs_per_genome_figure <- crispr_near_cas_density +
  number_of_crisprs_scatterplot +
  orphan_crispr_density +
  plot_layout(design = design,
              axes = "collect")

crisprs_per_genome_figure
```

From this figure, it appears that by far the most genomes have no CRISPR
arrays at all, and otherwise they mostly have one CRISPR array near
*cas* genes (one contig containing CRISPRs). At most, CCTyper has found
3 CRISPRs near *cas* genes and up to 4 orphan CRISPRs Let's see this
distribution separately between *C. jejuni* and *coli*, and look at the
number of spacers per genome.

## Arrays per genome and per species {#arrays-per-genome-and-per-species}

```{r crisprs_per_genome_stats}
total_genomes = nrow(annotated_crispr_number_df)

annotated_crispr_number_df %>%
  count(`CRISPRs near cas`, name = "Genomes") %>%
  mutate(Percentage = round(Genomes / total_genomes * 100, 2))

prepare_stats_df <- function(numbers_df, stat, species = "*") {
  return(numbers_df %>%
           filter(grepl(pattern = species, x = Species)) %>%
           group_by({{ stat }}) %>%
           summarise(Genomes = length({{ stat }})) %>%
           mutate(total_genomes = sum(Genomes),
                  Percentage = round(Genomes / total_genomes * 100, 2),
                  ymax = cumsum(Percentage),
                  ymin = c(0, head(ymax, n=-1)),
                  label_position = (ymax + ymin) / 2,
                  label = paste0({{ stat }}, " CRISPRs:\n", Percentage, "%")) %>%
           select(-total_genomes)
  )
}

make_donut_chart <- function(stats_df) {
  return(
    ggplot(
      data = stats_df,
      mapping = aes(ymax = ymax, ymin = ymin,
                    xmax = 4, xmin = 3,
                    fill = -label_position)) +
      geom_rect() +
      coord_polar(theta = "y") +
      xlim(c(2, 4)) +
      geom_text(x = 4.2, aes(label = label, y = label_position),
                size = 3, position = position_dodge(0.3)) +
      theme_void() +
      theme(legend.position = "none")
  )
}

print("CRISPRs in Campylobacter jejuni")
crisprs_jejuni_df <- prepare_stats_df(
  numbers_df = annotated_crispr_number_df,
  stat = `CRISPRs near cas`,
  species = "Campylobacter_D jejuni")

crisprs_jejuni_df[,1:3]
# The number of other jejuni subspecies(?) is too low to do
# separate analyses, so just put them all together

print("Orphan CRISPRs in C. jejuni")
orphan_crisprs_jejuni <- prepare_stats_df(
  numbers_df = annotated_crispr_number_df,
  stat = `Orphan CRISPRs`,
  species = "Campylobacter_D jejuni")

orphan_crisprs_jejuni[,1:3]

print("CRISPRs in Campylobacter coli")
crisprs_coli <- prepare_stats_df(
  numbers_df = annotated_crispr_number_df,
  stat = `CRISPRs near cas`,
  species = "Campylobacter_D coli")

crisprs_coli[,1:3]

print("Orphan CRISPRs in C. coli")
orphan_crisprs_coli <- prepare_stats_df(
  numbers_df = annotated_crispr_number_df,
  stat = `Orphan CRISPRs`,
  species = "Campylobacter_D coli")

orphan_crisprs_coli[,1:3]
```

Or, shown in a different way:

```{r crispr_prevalence_numbers}
annotated_crispr_number_df %>%
  count(contains_crisprs) %>%
  mutate(Percentage = round(n / total_genomes * 100, 2))

annotated_crispr_number_df %>%
  count(contains_crisprs, simple_species) %>%
  mutate(Percentage = case_when(
    simple_species == "jejuni" ~ round(n / annotated_crispr_number_df %>%
                                         filter(simple_species == "jejuni") %>%
                                         nrow() * 100, 2),
    simple_species == "coli" ~ round(n / annotated_crispr_number_df %>%
                                       filter(simple_species == "coli") %>%
                                       nrow() * 100, 2),
    TRUE ~ 0)
    )%>%
  arrange(desc(simple_species))
```

These tables again show the prevalence of CRISPR arrays among
*Campylobacter* genomes. 31% of *C. jenuni* and 70% of *C. coli* genomes
have no CRISPR arrays as detected in our analyses.

```{r crispr_prevalence_donuts}
#| fig-cap: "Prevalence of CRISPR arrays"
#| label: fig-crisprs_per_genome_donut
#| fig-height: 3
#| fig-width: 7

crisprs_near_cas_figure <- make_donut_chart(
  prepare_stats_df(numbers_df = annotated_crispr_number_df,
                   stat = `CRISPRs near cas`)
) +
  ggtitle("Overall") +
  make_donut_chart(crisprs_jejuni_df) +
  ggtitle("jejuni") +
  make_donut_chart(crisprs_coli) +
  ggtitle("coli")

crisprs_near_cas_figure
```

That is a visual and numerical impression of the prevalence of CRISPRs
in *C. jejuni* and *C. coli* genomes. It seems as though the prevalence
is quite different between species. Let's test that statistically.

```{r crisprs_per_species_test}
crisprs_per_species_table <- annotated_crispr_number_df %>%
  group_by(`CRISPRs near cas`, simple_species) %>%
  summarise(genomes = length(`CRISPRs near cas`)) %>%
  ungroup() %>%
  xtabs(formula = genomes ~ `CRISPRs near cas` + simple_species, data = .)

crisprs_per_species_table

crisprs_per_species_test <- prop_test(
  x = crisprs_per_species_table, detailed = T)

crisprs_per_species_test
```

Two-sided $\chi^2$ shows a significant difference in prevalence of
CRISPR arrays between *C. jejuni* and *C. coli* ($\chi$ = 2409, df = 3,
p = 0). This may be loosely translated into: *C. jejuni* genomes more
frequently have CRISPRs than *C. coli*.

Now let's see the predicted type of the CRISPR arrays (using the column
`Prediction` from the (concatenated) files `crisprs_near_cas.tab` and
`crisprs_orphan.tab`).

## Type of CRISPR arrays

```{r view_type_of_crisprs}
selected_metadata <- campylobacter_metadata %>%
    select(sample_accession, country, host, isolation_source,
           scientific_name, tax_id, Species, description)

annotated_crispr_df <- rbind(
  left_join(
    x = selected_metadata,
    y = crisprs_near_cas_df,
    by = "sample_accession"
  ) %>%
    mutate(orientation = "near_cas"),
  left_join(
    x = selected_metadata,
    y = crisprs_orphan_df,
    by = "sample_accession"
    ) %>%
    mutate(orientation = "orphan")
  ) %>%
  mutate(
    simple_species = if_else(
    grepl(pattern = "jejuni", x = Species),
    "jejuni", "coli"),

    N_spacers = case_when(
      N_repeats > 1 ~ N_repeats - 1,
      is.na(N_repeats) ~ 0,
      TRUE ~ 0
    )
  )

annotated_crispr_df %>%
  count(orientation, Prediction) %>%
  arrange(orientation, desc(n))

annotated_crispr_df %>%
  count(simple_species, orientation, Prediction) %>%
  arrange(desc(simple_species), orientation, desc(n))
```

Among the both the CRISPR arrays with *cas* genes nearby and the orphan
CRISPRs the most prevalent type predicted is II-C. The second most
prevalent type is 'unknown', which might be II-C with low certainty.
This pattern occurs in both *C. jejuni* and *C. coli*. (Note:
'Prediction = NA' refers to absence of CRISPRs, genomes with no CRISPRs
'near_cas' or 'orphan'.)

Now that we have seen the prevalence of CRISPR arrays and their type,
let's have a closer look at the number of CRISPR spacers and repeats
within each array.

# CRISPR spacers per genome {#crispr-spacers-per-genome}

From a little manual inspection, I found that CCTyper reports one more
repeat per genome than spacers (as counted from the entries in the fasta
files generated). Therefore, number of spacers are reported as number of
repeats (`N_repeats`) minus one.

```{r spacers_per_genome}
#| fig-cap: Total number of CRISPR spacers
#| label: fig-spacers_per_genome

total_spacer_scatter_data <- annotated_crispr_df %>%
  pivot_wider(id_cols = c(sample_accession, simple_species),
              names_from = orientation,
              values_from = N_spacers,
              values_fn = sum)

number_of_spacers_scatterplot <- ggplot(
  data = total_spacer_scatter_data,
  mapping = aes(x = near_cas,
                y = orphan)
) +
  geom_point(position = position_jitter(),
             size = 1, alpha = 0.3) +
  theme_pubr() +
  labs(x = "CRISPR spacers near cas",
       y = "Orphan CRISPR spacers")

spacers_near_cas_density = ggplot(
  data = total_spacer_scatter_data,
  mapping = aes(x = near_cas)) +
  geom_density(fill = "grey20") +
  theme_pubr() +
  theme(axis.title.x = element_blank())

orphan_spacer_density = ggplot(
  data = total_spacer_scatter_data,
  mapping = aes(y = orphan)) +
  geom_density(fill = "grey20") +
  theme_pubr() +
  theme(axis.title.y = element_blank())

spacers_per_genome_figure <- spacers_near_cas_density +
  number_of_spacers_scatterplot +
  orphan_spacer_density +
  plot_layout(design = design,
              axes = "collect")

spacers_per_genome_figure
```

This figure shows (again) that orphan CRISPRs are relatively rare, but
when they occur they may contain up to 23 spacers. The most commonly
occurring number of spacers is 3. As for the CRISPRs with *cas* genes
nearby, most CRISPR arrays contain up to 13 spacers (each at least 100
times) with higher numbers being observed less often. The minimum number
of spacers is 2, and the max 45. (Note that these numbers sum all
spacers if there are multiple arrays!)

## Spacers per species {#spacers-per-species}

```{r total_spacers_per_species}
#| fig-cap: "Total spacers per species"
#| label: fig-total_spacers_per_species

annotated_crispr_df %>%
  ggplot(mapping = aes(x = N_repeats - 1)) +
  geom_histogram(binwidth = 1) +
  facet_wrap(vars(simple_species, orientation),
             scales = "free_y",
             labeller = labeller(
               simple_species = c(coli = "C. coli", jejuni = "C. jejuni"),
               orientation = c(near_cas = "Near cas", orphan = "Orphan")),
             axes = "all_x"
             )+
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_pubr() +
  labs(x = "Number of spacers",
       y = "Count")
```

There appears to be a difference in distribution of the number of CRISPR
spacers between *C. jejuni* (bottom) and *C. coli* (top). In *C. jejuni*
there is a clear anticorrelation between number of spacers and
frequency: most arrays harbour 2 spacers and for each added spacer the
frequency decreases. This pattern does not apply to *C. coli*: the most
common *cas*-containing array has 5 spacers and frequencies of arrays
with 11 and 13 spacers are higher than those for 10, 12, 14 or more
spacers. This might be correlated with other underlying biological data,
such as the origin of the genomes (different environments, or
lineages?).

# Length of spacers and repeats {#length-of-spacers-and-repeats}

CCTyper reports for each array the length of the repeats and the mean
length of the CRISPR spacers with standard error of the mean (SEM; as
`Repeat_len`, `Spacer_len_avg`, and `Spacer_len_sem`). From previous
tests and discussions it appears that these may shift slightly between
genomes, while the total length remains the same, meaning that for
instance a repeat may be 3bp longer and the spacer 3bp shorter compared
to a similar array in another genome. Let's make a correlation dot plot
to show this.

```{r repeat_and_spacer_length}
#| fig-height: 5
#| fig-width: 8
#| label: fig-repeat_and_spacer_length
#| fig-cap: "CRISPR repeat and spacer length"

repeat_and_spacer_length_figure <- ggplot(
  data = annotated_crispr_df,
  mapping = aes(x = Spacer_len_avg,
                y = Repeat_len)
) +
  geom_point(size = 0.8, alpha = 0.8) +
  theme_pubr() +
  stat_cor(method = "pearson", label.x.npc = 0.6) +
  labs(x = "Spacer length (bp)",
       y = "Repeat length (bp)")

repeat_length_histogram <- ggplot(
  annotated_crispr_df,
  mapping = aes(y = Repeat_len)) +
  geom_histogram(binwidth = 1) +
  theme_pubr() +
  labs(y = NULL,
       x = "Count")

spacer_length_histogram <- ggplot(
  annotated_crispr_df,
  mapping = aes(x = Spacer_len_avg)) +
  geom_histogram(binwidth = 1) +
  theme_pubr() +
  labs(x = NULL,
       y = "Count")

spacer_length_histogram +
  plot_spacer() +
  repeat_and_spacer_length_figure +
  repeat_length_histogram +
  plot_layout(widths = c(3, 1),
              heights = c(1, 3))
```

Indeed, lengths of repeats and spacers are highly correlated (Pearson's
R = -0.99, p \< 0.0001).The most commonly found combination is spacers
of 30 bp long with repeats of 36 bp. It is likely that those are then
the canonical lengths and deviations - especially those where the
combined length is still 66 - may be the results of technical
inaccuracies. Some combinations have different combined lengths and are
more likely to be biologically different.

# Number of unique spacers {#number-of-unique-spacers}

In this dataset of 19,445 genomes there are 11,301 genomes (58%) that
contain CRISPR arrays. We have seen that there are genomes with up to 23
CRISPR spacers near *cas* genes and 13 orphan spacers. Also, most of
these spacers are 30 bp long, with exceptions from 26-51 bp. Now if we
collect all these spacers and cluster them, we can try and identify
unique spacers that may represent the biological spacer (filtering
sequencing and detection artifacts). Furthermore, using this approach we
may infer whether this dataset is saturated, meaning we have likely
sampled all exiting spacers in *C. jejuni* and *C. coli*. To do that, we
first have to establish a proper clustering cut-off.

```{r all_spacers_clustered}
#| label: fig-all_spacers_clustered
#| fig-cap: "CRISPR spacer clusters"

all_spacer_clusters <- read_delim(here("data/tmp/cctyper/spacer_cluster_summary.tsv"),
                                  show_col_types = F)

cluster_analysis_figure <- ggplot(
  data = all_spacer_clusters,
  mapping = aes(x = Cutoff,
                y = Clusters)
) +
  geom_bar(stat = "identity") +
  theme_pubr() +
  labs(title = paste("CRISPR spacer clusters, total spacers:", 
                     format(all_spacer_clusters$Total_sequences[1],
                            big.mark = ",")),
       x = "Cut-off (%)",
       y = "Number of clusters") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  geom_text(aes(y = Clusters - 250,
                label = paste("Cut-off:\n", Cutoff, "\n---\n",
                              format(Clusters,
                                     big.mark = ","),
                              "\nclusters"),
                hjust = "center",
                vjust = 1),
            angle = 0,
            size = 4,
            color = "grey75")

cluster_analysis_figure
```

From a total of almost 72k spacers, there appear to be roughly 12-14k
unique spacers, based on clustering by CD-HIT-EST. A cut-off of 1 means
spacers are only clustered if they are identical: among the 72k spacers
are 14,335 unique sequences. Allowing any mismatch (compared to the
shorter sequence) can cluster spacers further to just over 12k clusters.
Each bar represents allowing one more mismatch/mutation, i.e., the
figure shows clusters with 0-6 mismatches.\
*Note: CD-HIT-EST does not work with lower cut-offs than 80% (=0.8).*

In these results, I can see no clear breakpoint that may inform the
decision on a particular cut-off.

# Repeat sequence summary {#repeat-sequence-summary}

Look at the consensus repeat sequences to get an idea of the diversity
and possible errors in calling.

```{r count_consensus_repeat_sequences}
annotated_crispr_df %>%
  count(Consensus_repeat, Repeat_len) %>%
  arrange(desc(n))
```

The top two consensus sequences occur evenly frequently and are each
others' reverse complement. The next two are variants that lack either
the first or last nucleotide (both from the same strand, 'AT-start'), at
roughly equal frequencies. The fifth and sixth are one nucleotide longer
(from either strand, with an A appended or T prepended = identical). The
next sequence is actually different
(`ATTTTAGTCCCTTTTTAAATTTCTTTATGGTAAAAT`), still at 36 bp long. Then
follow one with a single point mutation and some length variants. Some
clustering (with `CDHIT-EST`) should probably be able to help find the
actually different repeat sequences.

Most common repeat (in 'AT-start' orientation):
`ATTTTACCATAAAGAAATTTAAAAAGGGACTAAAAC`

For comparison, the 'GT-start' orientation (reverse complement):
`GTTTTAGTCCCTTTTTAAATTTCTTTATGGTAAAAT`

# Estimated assembly quality {#estimated-assembly-quality}

The genomes collected by AllTheBacteria have all gone through their
quality control, including [CheckM2](#0). (Also see the
[documentation](https://allthebacteria.readthedocs.io/en/latest/sample_metadata.html#checkm2).)
The results are available as separate tab-separated text file and should
allow for a simple visualisation of the estimated completeness and
contamination scores.

```{r assembly_quality}
#| label: fig-assembly_quality
#| fig-cap: "CheckM2 and other assembly quality scores"
#| fig-height: 6
#| fig-width: 7

# Read the CheckM2 results file and filter out the Campylobacters
checkm2_results <- read_delim(here("data/ATB/checkm2.tsv.gz"),
                              show_col_types = F) %>%
  filter(Sample %in% campylobacter_metadata$sample_accession)

checkm2_figure <- checkm2_results %>%
  ggplot(mapping = aes(x = Completeness_General,
                       y = Contamination)) +
  geom_point(size = 0.6, alpha = 0.5) +
  labs(x = "Completeness (%)",
       y = "Contamination (%)") +
  theme_pubr()

quality_df <- checkm2_results %>%
  # Drop unnecessary columns:
  select(-c(Completeness_General, Contamination, Completeness_Specific,
            Completeness_Model_Used, Translation_Table_Used, Additional_Notes)) %>%
  # Pivot columns of interest into one long column to enable facetting
  pivot_longer(cols = c(Coding_Density, Contig_N50, Average_Gene_Length, Genome_Size,
                        GC_Content, Total_Coding_Sequences))

other_quality_boxplots <- quality_df %>%
  ggplot(mapping = aes(x = name, y = value)) +
  geom_boxplot() +
  facet_wrap(~name, scales = "free") +
  theme_pubr() +
  theme(axis.title = element_blank(),
        axis.text.x = element_blank())

checkm2_figure / other_quality_boxplots
```

As expected, all CheckM2 quality scores are \>95% completeness and \<5%
contamination, also known as 'high-quality'. The other assembly
statistics reveal that genomes are around 1.7Mb long (median: 1,702,242
bp), have an average (and median) GC-content of around 30%. The genomes
harbour around 1,800 genes (median: 1,786) of 300 amino acids? long
(median: 299.45), which bring the coding density to 94% (median: 93.8%).

------------------------------------------------------------------------

# Used software

```{r session_info}
sessionInfo()
```
