#! /usr/bin/env python3

## CCTyper extender:
## Read the output files to generate useful files for downstream processing:
## 1. BED files for CRISPR-Cas loci, CRISPR arrays and cas genes
## 2. (Optionally) use the BED files to extract regions from FASTA file?
## 3. Comprehensive CRISPR and cas gene output in one file
##
## To make this, I will need a number of functions:
##  - Take a directory from the command-line
##  - Identify relevant CCTyper output files
##      - CRISPR_Cas.tab for CRISPR-Cas locus (reports positions of cas genes!)
##      - cas_operons*.tab for cas gene info
##      - hmmer.tab for gene lengths
##      - crisprs_*.tab for CRISPR array info
##
## For the BED files, use the following fields:
## 1. contig ID ('chromosome')
## 2. start position
## 3. end position
## 4. name (CRISPR array/cas operon ID)
## 5. score (must be between 0 and 1000: number of CRISPR repeats or cas genes)
## 6. strand (+, - or .)

### Algorithm suggestion:
# 1. 'find properties'? (look for crispr and/or cas)
# 2. look up info (as complete as possible)
# 3. write to CRISPR-Cas overview table
# 4. extract data for BED files and write to BED

import argparse
from pathlib import Path
import pandas as pd
import string
from operator import itemgetter
import ast


def parse_arguments():
    """
    Parse arguments from the command line:
     -d/--directory = the directory to work in (CCTyper's output directory)
     -h/--help = show help
    """
    parser = argparse.ArgumentParser(
        prog="CCTyper_extender",
        description="Read the output generated by CCTyper to generate"
        "files useful for downstream processing.",
    )

    required = parser.add_argument_group("Required arguments")

    required.add_argument(
        "-d",
        "--directory",
        dest="directory",
        required=True,
        type=str,
        help="CCTyper output directory",
    )

    args = parser.parse_args()

    return args


def find_positions(directory):
    """
    Search the input directory for CRISPR-Cas files to determine their positions
    the genome. Write the found information to BED files. If no relevant files
    are found, only write a message to standard output.
    """
    work_dir = Path(directory)
    assert work_dir.is_dir(), (
        "%s is not a directory! Please provide a valid directory." % work_dir
    )

    crispr_cas_df = pd.DataFrame(
        columns=[
            "Sample_accession",
            "Contig",
            "CRISPR_ID",
            "CRISPR_start",
            "CRISPR_end",
            "Near_cas",
            "Trusted",
            "Repeat_subtype",
            "Repeat_type_probability",
            "Consensus_repeat",
            "N_repeats",
            "Repeat_len",
            "Repeat_identity",
            "Spacer_len_avg",
            "Spacer_len_sem",
            "Operon_ID",
            "Distance_to_CRISPR",
            "Cas_start",
            "Cas_end",
            "Best_type",
            "Best_score",
            "Genes",
            "Complete_interference",
            "Complete_adaptation",
            "Strand_cas",
            "Gene_lengths_aa",
        ]
    )  # Store both CRISPR array and cas operon information

    ### Start by searching whether there is a CRISPR-Cas locus (complete),
    ### only cas genes (`cas_operons.tab`), or only orphan crispr arrays
    ### (`crispr_orphan.tab`). If none of these matches, there is nothing
    ### to do!
    ### There might also be combinations of these, which are worthwhile
    ### mentioning.

    #########################################
    ### BELOW HERE IS THE ORIGINAL SCRIPT ###
    #########################################
    # Try finding the CRISPR-Cas loci
    crispr_cas_file = work_dir / "CRISPR_Cas.tab"
    if crispr_cas_file.is_file():
        print("CRISPR-Cas found in %s" % work_dir.name)

        # CRISPR-Cas data from CRISPR-Cas Typer (CCTyper)
        cc_data = pd.read_csv(crispr_cas_file, sep="\t")
        contigs = list(cc_data["Contig"])  # contig name as string
        operons = list(cc_data["Operon"])  # cas gene operon ID as string
        crisprs = list(cc_data["CRISPRs"])  # CRISPR array ID
        crisprs = [crispr.strip("[]'\"") for crispr in crisprs]
        cas_positions = list(cc_data["Operon_Pos"])  # cas operon start and end as list

        ## Read cas operon information, store in list and write BED file
        cas_file = work_dir / "cas_operons_putative.tab"
        cas_data = pd.read_csv(cas_file, sep="\t")
        cas_operons_info = []

        cas_operons_bed_file = work_dir / "Cas_operons.bed"

        hmmer_file = work_dir / "hmmer.tab"
        hmmer_data = pd.read_csv(hmmer_file, sep="\t")

        with open(cas_operons_bed_file, "w") as outfile:
            for index in range(len(operons)):
                contig = contigs[index]
                # Extract sample name, which is split by a dot: 'sample.contig'
                sample_accession = contig.split(".")[0]
                positions = cas_positions[index].strip("[]").split(", ")
                start = positions[0]
                stop = positions[1]
                operon = operons[index]
                # Use `ast.literal_eval()` to read CCTyper's output file lists as list
                # rather than strings.
                cas_genes = ast.literal_eval(
                    cas_data[cas_data["Operon"] == operon]["Genes"].iloc[0]
                )
                number_of_genes = len(cas_genes)

                # Try to infer strand from these cas genes:
                strand_adaptation = cas_data[cas_data["Operon"] == operon][
                    "Strand_Adaptation"
                ].iloc[0]
                strand_interference = cas_data[cas_data["Operon"] == operon][
                    "Strand_Interference"
                ].iloc[0]

                if strand_adaptation == 1 and strand_interference == 1:
                    strand = "+"
                elif strand_adaptation == -1 and strand_interference == -1:
                    strand = "-"
                else:
                    strand = "."

                cas_operons_info.append(
                    [contig, operon, int(start), int(stop), number_of_genes, strand]
                )

                cas_operons_bed_string = "%s\t%s\t%s\t%s\t%s\t%s\n" % (
                    contig,
                    start,
                    stop,
                    operon,
                    number_of_genes,
                    strand,
                )

                outfile.write(cas_operons_bed_string)

                # Look up cas operon data in `CRISPR_Cas.tab` and `cas_operons_putative.tab`
                distance = (
                    cc_data[cc_data["Operon"] == operon]["Distances"]
                    .iloc[0]
                    .strip("[]")
                )
                best_type = cas_data[cas_data["Operon"] == operon]["Best_type"].iloc[0]
                best_score = cas_data[cas_data["Operon"] == operon]["Best_score"].iloc[
                    0
                ]
                complete_interference = cas_data[cas_data["Operon"] == operon][
                    "Complete_Interference"
                ].iloc[0]
                complete_adaptation = cas_data[cas_data["Operon"] == operon][
                    "Complete_Adaptation"
                ].iloc[0]

                gene_lengths = (
                    []
                )  # Store as list (need to be extracted from `hmmer.tab`)
                for index in range(len(cas_genes)):
                    gene = cas_genes[index]
                    # Use `ast.literal_eval()` to read CCTyper's output file lists as list
                    # rather than strings.
                    position = ast.literal_eval(
                        cas_data[cas_data["Operon"] == operon]["Positions"].iloc[0]
                    )[index]
                    orf = "%s_%s" % (contig, position)
                    evalue = float(
                        ast.literal_eval(
                            cas_data[cas_data["Operon"] == operon]["E-values"].iloc[0]
                        )[index]
                    )
                    gene_length = hmmer_data[
                        (hmmer_data["ORF"] == orf) & (hmmer_data["Eval"] == evalue)
                    ]["qlen"].iloc[0]
                    gene_lengths.append(gene_length)

                # And write these stats to a dictionary (to-be dataframe)
                crispr_cas_dict = {
                    "Sample_accession": sample_accession,
                    "Contig": contig,
                    "Operon_ID": operon,
                    "Distance": distance,
                    "Cas_start": start,
                    "Cas_end": stop,
                    "Best_type": best_type,
                    "Genes": cas_genes,
                    "Complete_interference": complete_interference,
                    "Complete_adaptation": complete_adaptation,
                    "Strand_cas": strand,
                    "Gene_lengths_aa": gene_lengths,
                }

        ## Read CRISPR array information, store in list and write BED file
        crispr_file = work_dir / "crisprs_all.tab"
        crispr_data = pd.read_csv(crispr_file, sep="\t")
        crispr_info = []

        arrays_bed_file = work_dir / "CRISPR_arrays.bed"
        with open(arrays_bed_file, "w") as outfile:
            for crispr in crisprs:
                contig = crispr.rstrip(string.digits).rstrip("_")
                crispr_start = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Start"
                ].iloc[0]
                crispr_stop = crispr_data[crispr_data["CRISPR"] == crispr]["End"].iloc[
                    0
                ]
                number_of_repeats = crispr_data[crispr_data["CRISPR"] == crispr][
                    "N_repeats"
                ].iloc[0]
                crispr_info.append(
                    [crispr, crispr_start, crispr_stop, number_of_repeats]
                )

                crisprs_bed_string = "%s\t%s\t%s\t%s\t%s\t%s\n" % (
                    contig,
                    crispr_start,
                    crispr_stop,
                    crispr,
                    number_of_repeats,
                    strand,
                )

                outfile.write(crisprs_bed_string)

                # Look up extra stats in `crisprs_all.tab`
                trusted = crispr_data[crispr_data["CRISPR"] == crispr]["Trusted"].iloc[
                    0
                ]
                repeat_subtype = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Subtype"
                ].iloc[0]
                repeat_subtype_prob = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Subtype_probability"
                ].iloc[0]
                consensus_repeat = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Consensus_repeat"
                ].iloc[0]
                repeat_len = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Repeat_len"
                ].iloc[0]
                repeat_identity = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Repeat_identity"
                ].iloc[0]
                spacer_len_avg = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Spacer_len_avg"
                ].iloc[0]
                spacer_identity = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Spacer_identity"
                ].iloc[0]
                spacer_len_sem = crispr_data[crispr_data["CRISPR"] == crispr][
                    "Spacer_len_sem"
                ].iloc[0]

                # And put them in the dictionary (to-be dataframe)
                crispr_cas_dict["CRISPR_ID"] = crispr
                crispr_cas_dict["CRISPR_start"] = crispr_start
                crispr_cas_dict["CRISPR_end"] = crispr_stop
                crispr_cas_dict["Near_cas"] = (
                    "near_cas"  # By definition, because it is read from 'CRISPR_cas.tab'
                )
                crispr_cas_dict["Trusted"] = trusted
                crispr_cas_dict["Repeat_subtype"] = repeat_subtype
                crispr_cas_dict["Repeat_type_probability"] = repeat_subtype_prob
                crispr_cas_dict["Consensus_repeat"] = consensus_repeat
                crispr_cas_dict["N_repeats"] = number_of_repeats
                crispr_cas_dict["Repeat_len"] = repeat_len
                crispr_cas_dict["Repeat_identity"] = repeat_identity
                crispr_cas_dict["Spacer_len_avg"] = spacer_len_avg
                crispr_cas_dict["Spacer_identity"] = spacer_identity
                crispr_cas_dict["Spacer_len_sem"] = spacer_len_sem

                print(crispr_cas_dict)

                # To accomodate a mix of string values (e.g. Sample_accession) and lists
                # (e.g. cas genes), create a dataframe of the dictionary values (list type),
                # which by default reads the list as rows in one column. Attach the key
                # values as index and then transpose the dataframe to wide format (`.T`)
                print(
                    pd.concat(
                        [
                            crispr_cas_df,
                            pd.DataFrame(
                                crispr_cas_dict.values(), index=crispr_cas_dict.keys()
                            ).T,
                        ]
                    )
                )
                # Otherwise, those list values will cause duplicate entries: one row for
                # each gene present in the operon and all other values are copied as well.

        ## Combine CRISPR array and cas operon information to create CRISPR-Cas BED
        crispr_cas_info = []
        crispr_cas_bed_file = work_dir / "CRISPR-Cas.bed"
        with open(crispr_cas_bed_file, "w") as outfile:
            for index in range(len(crispr_info)):
                crispr_cas_info.append(cas_operons_info[index] + crispr_info[index])
                print(crispr_cas_info)
                contig = crispr_cas_info[index][0]
                # Grab both the start and stop positions for the cas operon and the CRISPR array
                all_starts_and_stops = itemgetter(2, 3, 7, 8)(crispr_cas_info[index])
                start = min(all_starts_and_stops)
                stop = max(all_starts_and_stops)
                array_name = crispr_cas_info[index][6]
                number_of_repeats = crispr_cas_info[index][9]
                strand = crispr_cas_info[index][5]

                crispr_cas_bed_string = "%s\t%s\t%s\t%s\t%s\t%s\n" % (
                    contig,
                    start,
                    stop,
                    array_name,
                    number_of_repeats,
                    strand,
                )
                outfile.write(crispr_cas_bed_string)

    else:
        print("No CRISPR-Cas system found in %s" % work_dir.name)

    return 0


def extract_crispr_cas_info(crispr_cas_file):
    """
    Takes a `CRISPR_Cas.tab` file to read relevant information:
    1. Contig ID
       - from that, derive sample accession
    2. Cas gene operon ID
    3. Cas gene start and end positions
    4. Distance from cas genes to CRISPR array
    5. CRISPR array ID
    6. That it is a complete CRISPR-Cas system
    """
    cc_data = pd.read_csv(crispr_cas_file, sep="\t")
    cc_list = []

    # The file may have multiple entries (arrays/loci):
    #  read them as a list
    contigs = list(cc_data["Contig"])
    # Extract sample name, which is split by a dot: 'sample.contig'
    sample = contigs[0].split(".")[0]
    operons = list(cc_data["Operon"])  # cas gene operon ID as string
    crisprs = list(cc_data["CRISPRs"])  # CRISPR array ID
    crisprs = [crispr.strip("[]'\"") for crispr in crisprs]
    cas_positions = list(cc_data["Operon_Pos"])
    distances = list(cc_data["Distances"])

    # For each array that is in the CRISPR-Cas file:
    for number in range(len(crisprs)):
        # Collect the matching data
        positions = cas_positions[number].strip("[]").split(", ")
        start = positions[0]
        stop = positions[1]
        distance = distances[number].strip("[]")

        # Save that in a list
        cc_list.append(
            [
                sample,
                contigs[number],
                operons[number],
                start,
                stop,
                distance,
                crisprs[number],
                "crispr-cas",
            ]
        )

    # And return that list object
    return cc_list


def annotate_cas_operon(operon, work_dir):
    """
    Take an operon ID to extract relevant information from
    `cas_operons_putative.tab` and `hmmer.tab`. This includes:
    1. A list of cas genes
    2. The number of genes
    3. Strand (inferred from cas genes: +, - or '.' for unknown/ambiguous)
    4. Prediction type
    5. Prediction score
    6. Interference completeness
    7. Adaptation completeness
    """
    cas_file = work_dir / "cas_operons_putative.tab"
    cas_data = pd.read_csv(cas_file, sep="\t")
    cas_file_extra = work_dir / "cas_operons.tab"
    if cas_file_extra.is_file():
        cas_data = pd.concat([cas_data, pd.read_csv(cas_file_extra, sep="\t")])
    else:
        pass

    hmmer_file = work_dir / "hmmer.tab"
    hmmer_data = pd.read_csv(hmmer_file, sep="\t")

    contig = operon.split("@")[0]
    # Use `ast.literal_eval()` to read CCTyper's output file lists as list
    # rather than strings.
    cas_genes = ast.literal_eval(
        cas_data[cas_data["Operon"] == operon]["Genes"].iloc[0]
    )
    number_of_genes = len(cas_genes)

    # Try to infer strand from these cas genes:
    strand_adaptation = cas_data[cas_data["Operon"] == operon][
        "Strand_Adaptation"
    ].iloc[0]
    strand_interference = cas_data[cas_data["Operon"] == operon][
        "Strand_Interference"
    ].iloc[0]

    if strand_adaptation == 1 and strand_interference == 1:
        strand = "+"
    elif strand_adaptation == -1 and strand_interference == -1:
        strand = "-"
    else:
        strand = "."

    best_type = cas_data[cas_data["Operon"] == operon]["Best_type"].iloc[0]
    best_score = cas_data[cas_data["Operon"] == operon]["Best_score"].iloc[0]
    complete_interference = cas_data[cas_data["Operon"] == operon][
        "Complete_Interference"
    ].iloc[0]
    complete_adaptation = cas_data[cas_data["Operon"] == operon][
        "Complete_Adaptation"
    ].iloc[0]

    gene_lengths = []  # Store as list (need to be extracted from `hmmer.tab`)
    for index in range(len(cas_genes)):
        gene = cas_genes[index]
        # Use `ast.literal_eval()` to read CCTyper's output file lists as list
        # rather than strings.
        position = ast.literal_eval(
            cas_data[cas_data["Operon"] == operon]["Positions"].iloc[0]
        )[index]
        # Now filter the matching info from `hmmer.tab`:
        # For each ORF take the lowest available E-value (= best hit).
        # Thanks to Sergio Polimante (2021) and Ynjxsjmh (2022)!
        #  https://stackoverflow.com/a/73383113
        hmmer_data = hmmer_data[
            hmmer_data["Eval"] == hmmer_data.groupby("ORF")["Eval"].transform("min")
        ]

        orf = "%s_%s" % (contig, position)
        gene_length = hmmer_data[hmmer_data["ORF"] == orf]["qlen"].iloc[0]
        gene_lengths.append(gene_length)

    cas_operon_info = [
        cas_genes,
        number_of_genes,
        strand,
        best_type,
        best_score,
        complete_interference,
        complete_adaptation,
    ]

    return cas_operon_info


def annotate_crispr_array(crispr, work_dir):
    """
    Given a list of CRISPR array IDs, look up relevant information in
    `crisprs_all.tab`. This includes:
    1. CRISPR start position
    2. CRISPR end position
    3. 'Trusted' (prediction evaluation by CCTyper)
    4. Repeat subtype
    5. Repeat subtype probability
    6. Consensus repeat
    7. Number of repeats
    8. Repeat length
    9. Repeat identity (BLAST to database of known repeats?)
    10. Spacer mean length
    11. Spacer identity
    12. Spacer length standard error of the mean (SEM)
    """
    ## Read CRISPR array information to return as a list
    crispr_file = work_dir / "crisprs_all.tab"
    crispr_data = pd.read_csv(crispr_file, sep="\t")
    crispr_info = []

    contig = crispr.rstrip(string.digits).rstrip("_")
    crispr_start = crispr_data[crispr_data["CRISPR"] == crispr]["Start"].iloc[0]
    crispr_stop = crispr_data[crispr_data["CRISPR"] == crispr]["End"].iloc[0]
    number_of_repeats = crispr_data[crispr_data["CRISPR"] == crispr]["N_repeats"].iloc[
        0
    ]

    trusted = crispr_data[crispr_data["CRISPR"] == crispr]["Trusted"].iloc[0]
    repeat_subtype = crispr_data[crispr_data["CRISPR"] == crispr]["Subtype"].iloc[0]
    repeat_subtype_prob = crispr_data[crispr_data["CRISPR"] == crispr][
        "Subtype_probability"
    ].iloc[0]
    consensus_repeat = crispr_data[crispr_data["CRISPR"] == crispr][
        "Consensus_repeat"
    ].iloc[0]
    repeat_len = crispr_data[crispr_data["CRISPR"] == crispr]["Repeat_len"].iloc[0]
    repeat_identity = crispr_data[crispr_data["CRISPR"] == crispr][
        "Repeat_identity"
    ].iloc[0]
    spacer_len_avg = crispr_data[crispr_data["CRISPR"] == crispr][
        "Spacer_len_avg"
    ].iloc[0]
    spacer_identity = crispr_data[crispr_data["CRISPR"] == crispr][
        "Spacer_identity"
    ].iloc[0]
    spacer_len_sem = crispr_data[crispr_data["CRISPR"] == crispr][
        "Spacer_len_sem"
    ].iloc[0]

    crispr_info = [
        crispr_start,
        crispr_stop,
        str(trusted),
        repeat_subtype,
        repeat_subtype_prob,
        consensus_repeat,
        number_of_repeats,
        repeat_len,
        repeat_identity,
        spacer_len_avg,
        spacer_identity,
        spacer_len_sem,
    ]

    return crispr_info


def create_bedfile(bed_entries, filename):
    """
    Given a list of entries and a filename, write the entries to the file!
    """
    with open(filename, "w") as outfile:
        for entry in bed_entries:
            outfile.write(entry)
    return 0


def extract_bed_entries(info_df, type):
    """
    Given a list of data needed to create BED files, and the type of BED file to
    be created (CRISPR array, cas genes, or entire CRISPR-Cas locus, as:
    'crispr', 'cas', or 'crispr-cas' or 'locus'), extract the relevant
    information from the list and pass this including filename to `create_bedfile()`.
    """

    ### THIS FUNCTION NEEDS TO BE COMPLETED ###
    ### IT DOES NOT WORK YET ###
    ### Maybe it is easier to just do this separately for each BED file,
    ### with or without seperate functions...
    bed_entries = []
    if type == "crispr":
        for info in info_df:
            bed_entries.append(info_df)


def main():
    arguments = parse_arguments()

    message = (
        "\n"
        "These are the command-line arguments:\n"
        "  DIRECTORY:\n"
        "{0}\n".format(arguments.directory)
    )

    print(message)

    #   # Check if the provided directory exists and is a directory
    work_dir = Path(arguments.directory)
    assert work_dir.is_dir(), (
        "%s is not a directory! Please provide a valid directory." % work_dir
    )

    # Look for the CRISPR-Cas file
    crispr_cas_file = work_dir / "CRISPR_Cas.tab"
    if crispr_cas_file.is_file():
        print("CRISPR-Cas found in %s" % work_dir.name)

        cc_info = extract_crispr_cas_info(crispr_cas_file=crispr_cas_file)
        print("CRISPR-Cas info: %s" % cc_info)

        for array in cc_info:
            operon = array[2]
            cas_info = annotate_cas_operon(operon=operon, work_dir=work_dir)

            print("Cas operon info: %s" % cas_info)

            crispr = array[-2]
            crispr_info = annotate_crispr_array(crispr=crispr, work_dir=work_dir)
            print("CRISPR array info: %s" % crispr_info)

    else:
        print("Sample %s has no complete CRISPR-Cas system." % work_dir.name)

    # Look for seperately reported cas operons
    cas_file = work_dir / "cas_operons.tab"
    if cas_file.is_file():
        print("Sample %s has a file for separate cas operons." % work_dir.name)
        operons_info = []
        with open(cas_file, "r") as infile:
            infile.readline()  # Skip the first (header) line

            for line in infile:
                elements = line.split("\t")
                operon = elements[1]  # The second entry (0-based) is the operon ID
                operons_info.append(
                    [annotate_cas_operon(operon=operon, work_dir=work_dir), "only_cas"]
                )

    else:
        print("Sample %s has no (extra) cas operons." % work_dir.name)

    # Finally, check for CRISPR arrays that may have no cas genes nearby
    crispr_file = work_dir / "crisprs_orphan.tab"
    if crispr_file.is_file():
        print("Sample %s has at least one orphan CRISPR array." % work_dir.name)
        crispr_info = []

        # Start reading the CRISPR array IDs
        with open(crispr_file, "r") as infile:
            infile.readline()  # Skip the first (header) line
            for line in infile:
                elements = line.split("\t")
                crispr_id = elements[1]  # The second entry (0-based) is the ID
                # Now check if it is not part of a CRISPR-Cas system
                # (To make doubly sure)
                try:
                    if any(crispr_id in sublist for sublist in cc_info):
                        pass  # Ignore the CRISPR that is already saved as CRISPR-Cas
                    else:
                        print(
                            "Sample %s has orphan CRISPR: %s"
                            % (work_dir.name, crispr_id)
                        )
                        crispr_info.append(
                            [
                                annotate_crispr_array(
                                    crispr=crispr_id, work_dir=work_dir
                                ),
                                "orphan_crispr",
                            ]
                        )
                except NameError:
                    # If CRISPR-Cas info has not been collected yet, lookup the CRISPR info!
                    print(
                        "Sample %s has orphan CRISPR: %s" % (work_dir.name, crispr_id)
                    )
                    crispr_info.append(
                        [
                            annotate_crispr_array(crispr=crispr_id, work_dir=work_dir),
                            "orphan_crispr",
                        ]
                    )

    else:
        print("Sample %s has no orphan CRISPRs." % work_dir.name)


if __name__ == "__main__":
    exit(main())
