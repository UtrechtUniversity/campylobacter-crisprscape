"""
Author: Sam Nooij
Organisation: Utrecht University
Department: Clinical Infectiology (KLIF), Infectious Diseases & Immunology,
  Biomolecular Health Sciences, Faculty of Veterinary Medicine
Date: 2024-11-06

Workflow for testing CRISPR analysis options
In contrast to the 'regular' Snakefile workflow, which works
per genome file, this workflow works per batch and runs GNU
parallel to parallelise processing of the genomes within
each batch.


Input: Fasta files of Campylobacter whole-genomes
Output: (various)

Example use:
    $ snakemake --profile config

N.B. Variables are set in the configuration files under `config`.
"""

from pathlib import Path
import functools
import operator

### Step 1: Import configuration file ###


configfile: Path("config/parameters.yaml")


# Use Python functions to automatically detect batches of genomes fasta files
# in the input directory as 'BATCHES' and 'SAMPLES'
INPUT_DIR = config["input_directory"]

BATCH_PATHS = list(Path(INPUT_DIR).glob("*"))
for batch in BATCH_PATHS:
    assert Path(batch).is_dir(), f"Batches must be directories, got {batch}"

BATCHES = [batch.stem for batch in BATCH_PATHS]

OUTPUT_DIR = config["output_directory"]


### Step 2: Specify output files ###


rule all:
    input:
        # Concatenated CCTyper output
        expand(OUTPUT_DIR + "cctyper/{batch}/{filename}-{batch}.tab",
               batch = BATCHES,
               filename = [ "CRISPR_Cas", "crisprs_all", "crisprs_near_cas", "crisprs_orphan" ]
        ),

        # geNomad output
        expand(
            OUTPUT_DIR + "genomad/{batch}/{batch}_aggregated_classification/{batch}_aggregated_classification.tsv",
            batch=BATCHES,
        ),

         # Jaeger output
         expand(
             OUTPUT_DIR + "jaeger/{batch}/complete",
             batch=BATCHES,
         ),


### Step 3: Define processing steps that generate the output ###


rule crisprcastyper:
    input:
        batch=INPUT_DIR + "{batch}/",
    output:
        OUTPUT_DIR + "cctyper/{batch}/complete"
    params:
        out_dir=OUTPUT_DIR + "cctyper/{batch}/",
    conda:
        "envs/cctyper.yaml"
    threads: config["cctyper"]["threads"]
    log:
        "log/cctyper/{batch}.txt",
    benchmark:
        "log/benchmark/cctyper/{batch}.txt"
    shell:
        """
parallel --jobs {threads} --retry-failed --halt='now,fail=1'\
 rm -rf "{params.out_dir}{{/.}}" &&\
 cctyper -t 1 {{}} "{params.out_dir}{{/.}}" > {log} 2>&1\
 ::: {input.batch}/*.fa

touch {output}
        """


rule collect_cctyper:
    input:
        OUTPUT_DIR + "cctyper/{batch}/complete"
    output:
        crispr_cas=OUTPUT_DIR + "cctyper/{batch}/CRISPR_Cas-{batch}.tab",
        crisprs_all=OUTPUT_DIR + "cctyper/{batch}/crisprs_all-{batch}.tab",
        crisprs_near_cas=OUTPUT_DIR + "cctyper/{batch}/crisprs_near_cas-{batch}.tab",
        crisprs_orphan=OUTPUT_DIR + "cctyper/{batch}/crisprs_orphan-{batch}.tab",
    threads: 1
    log:
        "log/cctyper/collect_{batch}.txt"
    benchmark:
        "log/benchmark/cctyper/collect_{batch}.txt"
    shell:
        """
bash bin/concatenate_cctyper_output.sh $(dirname {input}) > {log} 2>&1
        """


rule concatenate_batches:
    input:
        INPUT_DIR + "{batch}"
    output:
        temp(OUTPUT_DIR + "{batch}.fasta")
    threads: 1
    log:
        "log/concatenate_{batch}.txt"
    benchmark:
        "log/benchmark/concatenate_{batch}.txt"
    shell:
        """
cat {input}/*.fa > {output} 2> {log}
        """


rule batched_cctyper:
    input:
        OUTPUT_DIR + "{batch}.fasta"
    output:
        arguments=OUTPUT_DIR + "cctyper/test/{batch}/arguments.tab",
        putative_operons=OUTPUT_DIR + "cctyper/test/{batch}/cas_operons_putative.tab",
        genes=OUTPUT_DIR + "cctyper/test/{batch}/genes.tab",
        hmmer=OUTPUT_DIR + "cctyper/test/{batch}/hmmer.tab",
    params:
        out_dir=OUTPUT_DIR + "cctyper/test/{batch}",
    conda:
        "envs/cctyper.yaml"
    threads: config["cctyper"]["threads"]
    log:
        "log/cctyper/{batch}.txt"
    benchmark:
        "log/benchmark/cctyper/{batch}.txt"
    shell:
        """
rm -rf {params.out_dir}
cctyper -t {threads} {input} {params.out_dir} > {log} 2>&1
        """


rule genomad:
    input:
        fasta=OUTPUT_DIR + "{batch}.fasta",
        db=config["genomad_database"],
    output:
        aggregated_classification=OUTPUT_DIR + "genomad/{batch}/{batch}_aggregated_classification/{batch}_aggregated_classification.tsv",
        plasmid_summary=OUTPUT_DIR + "genomad/{batch}/{batch}_summary/{batch}_plasmid_summary.tsv",
        virus_summary=OUTPUT_DIR + "genomad/{batch}/{batch}_summary/{batch}_virus_summary.tsv",
    params:
        output_dir=OUTPUT_DIR + "genomad/{batch}/",
    conda:
        "envs/genomad.yaml"
    threads: config["genomad"]["threads"]
    log:
        "log/genomad/{batch}.txt",
    benchmark:
        "log/benchmark/genomad/{batch}.txt"
    shell:
        """
genomad end-to-end -t {threads} --cleanup --enable-score-calibration\
 {input.fasta} {params.output_dir} {input.db} > {log} 2>&1
        """


rule jaeger:
    input:
        batch=INPUT_DIR + "{batch}/"
    output:
        OUTPUT_DIR + "jaeger/{batch}/complete"
    params:
        output_dir=OUTPUT_DIR + "jaeger/{batch}/"
    conda:
        "envs/jaeger.yaml"
    threads: config["jaeger"]["threads"]
    log:
        "log/jaeger/{batch}.txt"
    benchmark:
        "log/benchmark/jaeger/{batch}.txt"
    shell:
        """
parallel --jobs {threads} --retry-failed --halt='now,fail=1'\
 Jaeger -p --workers 1 -i {{}} -o "{params.output_dir}{{/.}}" --overwrite\
 > {log} 2>&1 ::: {input.batch}/*.fa

touch {output}
        """
